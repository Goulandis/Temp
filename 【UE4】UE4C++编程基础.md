---
title: 【UE4】UE4C++编程入门
date: 2019-10-15 10:05:33
tags:
---



此学习记录在Unity3d的基础之上学习

# 一、UE4的文件结构

## 1.安装目录结构

![](【UE4】UE4基础/Snipaste_2019-10-15_10-16-42.png)

### DirectXRedist

 DirectXRedist是DirectX文件所在的地方。这个文件夹也包括了安装DirectX的安装包。

### Launcher

Launcher是引擎启动器所在文件夹。Launcher包含了如下子文件夹：

- Backup：这里是保存备份的工作。如果中途发生崩溃，或者出现了难以解决的错误，可以从这里恢复工作进度。
- Engine：这个文件夹包括了组成引擎的代码、库和内容。
- PatchStaging：这里保存了下载UE4版本的临时数据。
- VaultCache：这个文件夹包含了所有你从商城购买的资源的缓存。

### 4.10

4.10文件夹有如下子文件夹：

- Engine：它包含了所有源代码、库、资源、map文件之类的组成引擎的部分。
- Samples：UE4提供了两个示例Maps，这个文件夹包含了资源，蓝图等。
- Templates：UE4提供了不同类型游戏的模版，这个文件夹包含了不同类型游戏的内容和源代码

不同UE4版本目录结构可能有所不同，但大体上不会有太大差别、

## 2.项目目录结构

![](【UE4】UE4基础/Snipaste_2019-10-16_17-06-01.png)

### .vs

VS的智能解读和智能提示的缓存

### Binaries

编辑器热加载类的二进制文件

### Config

Config是配置文件，保存一些偏好设置等配置

### Content

Content文件与引擎里的Content文件对应

Content文件的目录结构

![](【UE4】UE4基础/Snipaste_2019-10-16_17-10-46.png)

其中**Collections**和**Developers**主要存放我们在使用引擎的时候生成的一些链接文件和临时文件。

在引擎中可以在View Options中选择是否在引擎理显示这两个文件夹，默认情况下，这两个文件夹是不显示的。

![](【UE4】UE4基础/Snipaste_2019-10-16_17-13-58.png)

**StartContent**文件就是我们创建工程时导入新手包

### Intermediate

Intermediate文件夹存放我们在引擎中构建的一些中间文件，如：光照的构建文件等等。

### Saved

Saved中保存项目的备份文件和开发日志

### Source

Source对应引擎中C++Class文件夹

### ARP.sln

VS解决方案的文件

### ARP

项目的启动文件

# 二、UE4的工作界面

## 1.开始目录

UE4支持两种工作模式，即蓝图模式和C++编程模式

**蓝图模式**

蓝图模式提供可视化编程，可以做到不写一句代码就可以实现一个完整的游戏，但是蓝图模式对于实现一些复杂的逻辑较为困难。

**C++编程模式**

C++编程模式是较为传统的游戏实现模式，主要以编写代码的方式来实现游戏模块，功能强大，使用灵活。

## 2.菜单栏

![](【UE4】UE4基础/Snipaste_2019-10-15_10-31-54.png)

**File**

创建、打开、保存关卡/地图和创建或打开项目。游戏打包也是在这里。这里也有不同的设置和建立配置可以修改，后面会详细说明。

**Edit**

撤销、恢复、剪切、复制、粘贴或者重复任何选中的对象（或一组选中的对象）。也可以设置偏好，例如自动保存开关和自动保存的时间、改变快捷键、改变测量单位（厘米、米或千米）。项目设置则提供了描述项目的内容设置、项目ID或项目该如何打包，还有该项目支持什么样的平台。更多的设置读者可以自行探索，直到调整到适合自己工作的方式。

**Window**

编辑器中的窗口布局是完全可以自定义的，这里可以选择增加或删除哪些窗口。你也可以通过鼠标点击窗口标签，然后拖动，再释放鼠标来手动调整窗口位置。注意，有时候窗口的标签默认是隐藏的，这时候点击左上角的黄色箭头，然后标签就会显示出来了。当你打乱了当前的窗口布局，又不知道如何恢复的时候，可以选择窗口菜单中的重置布局。

**Help**

官方教程、文档、论坛、回答中心等常用的超链接都会显示在这里。 

## 3.工具栏

![](【UE4】UE4基础/Snipaste_2019-10-15_10-36-15.png)

**Save Current**

保存当前的工作进度(当前关卡)，可以防止崩溃造成工作进度大量丢失。

我们一般使用Save All而不使用Save Current

![](【UE4】UE4基础/Snipaste_2019-10-15_10-39-37.png)

**Source Control**

默认是关闭的，版本管理是协作开发方式，并且它会记录每一次的更改，当你修改了文件，团队中的其他人就会更新修改的文件，并且如果他们修改了文件，你也会被更新文件。通过点击版本控制按钮，选择自己团队的版本控制工具来激活版本管理。

**Content**

包含了所有资源、代码、关卡和其它游戏开发用到的内容。

Content对应Content Browser窗口

![](【UE4】UE4基础/Snipaste_2019-10-15_10-42-21.png)

Marketplace

一个访问商城的快捷方式。

**Setting**

修改编辑器的设置。例如允许选择半透膜物体、选择组合物体等。引擎的可视化设置，例如分辨率、贴图渲染质量、抗齿锯等都可以在此处设置。

![](【UE4】UE4基础/Snipaste_2019-10-15_10-45-14.png) 

**Blueprints**

蓝图是一个UE4的很重要和很常用的特性。这里可以进入蓝图编辑器。

![](【UE4】UE4基础/Snipaste_2019-10-15_10-47-10.png)

**Cinematices**

你可以使用过场动画来创建电影艺术。

**Build**

当你构建你的关卡，引擎可以预计算灯光和可视化数据、产生导航网络和更新几何体。

![](【UE4】UE4基础/Snipaste_2019-10-15_10-49-05.png)

**Play**

当你点击播放按钮，在视图中会测试你的关卡和观察是否功能正常。当你点击播放后，会出现暂停、停止、弹出按钮 

- 暂停：当暂停后，你可以点击继续或逐帧播放。
- 停止：停止游戏测试，回到编辑模式。

![](【UE4】UE4基础/Snipaste_2019-10-15_10-50-02.png)

**Launch**

当你的游戏已经完成并且准备发布，点击启动按钮会制作、打包和生成可执行的应用程序文件（这依赖于选择的平台）。

![](【UE4】UE4基础/Snipaste_2019-10-15_10-50-54.png)

## 4.视口

 视口位于编辑器窗口中央，这里可以创建和调试你的游戏。将游戏对象都可以放置在这里来创建当前的场景。 

![](【UE4】UE4基础/Snipaste_2019-10-15_10-59-58.png)

**观察**

按下鼠标左键或右键的同时，你可以使用W、S、A、D来移动到观察的视角。

**选择**

鼠标点击左键。

 在视图上方的是视图工具栏，我们来逐一说明它们：

**视口选项**

这里可以切换到游戏模式，可以将场景像在游戏中那样展示出来，所以那些音量、隐藏的actors和actor图标都会被隐藏起来。还有沉浸模式，将会以全屏模式显示。还有其他设置选项可以被设置，所以最好自己亲自试试。

快捷键：G

![](【UE4】UE4基础/Snipaste_2019-10-15_11-06-57.png)

**视口投影类型**

这里有两种视口投影类型，一种是正交投影、一种是透视投影。透视投影符合人的视觉，所以看起来更像3D场景，而正交投影像是将某个轴去掉后的2D平面。



![](【UE4】UE4基础/Snipaste_2019-10-15_11-04-47.png)

**视口渲染模式**

设置显示的渲染模式，默认的是带光照模式，将游戏中的灯光显示在视口中。你可以切换到不带灯光模式，就会没有任何灯光了。线框模式，只会显示模型的线框。 

![](【UE4】UE4基础/Snipaste_2019-10-15_11-04-58.png)

 **显示**

设置哪些类型的actor可以显示出来，哪些类型被隐藏。

![](【UE4】UE4基础/Snipaste_2019-10-15_11-05-09.png)

**变换工具**

这里有三种变换方式。第一个是平移，第二个是旋转，第三个是缩放。

![](【UE4】UE4基础\Snipaste_2019-10-15_11-11-01.png)

使用方法和Unity一致

 **坐标系统**

切换全局坐标系和局部坐标系。如果选中的是全局坐标系，则变换会以世界坐标系的轴为准。如果选中的是局部坐标系，则变换会以物体自身旋转的方向的轴为准。

![](【UE4】UE4基础\Snipaste_2019-10-15_11-11-16.png)

**表面对齐、表面网格对齐、表面网格对齐值**

接着的这三个工具涉及到平移的对齐操作。表面对齐的时候，只要两个actor的轴心在底部，当它们靠近的时候就会自动对齐了。网格对齐，是每次移动的时候都会移动网格对齐值大小的值。

![](【UE4】UE4基础\Snipaste_2019-10-15_11-11-34.png)

**旋转网格对齐、旋转网格对齐值**

类似于表面网格对齐，旋转网格对齐每次旋转都是旋转某个固定的旋转网格对齐值。

![](【UE4】UE4基础\Snipaste_2019-10-15_11-11-45.png)

**缩放网格对齐、缩放网格对齐值**

类是于上面两个对齐，每次缩放的时候都是按某个固定的缩放网格对齐值来缩放。

![](【UE4】UE4基础\Snipaste_2019-10-15_11-11-59.png)

**摄像机速度**

设置当按下箭头键的时候摄像机移动的速度。

![](【UE4】UE4基础/Snipaste_2019-10-15_11-12-10.png)

**最大化和恢复视口**

当你点击右上角的这个按钮的时候，最会在透视视图和三视图+透视视图之间切换（见下图），三视图就是正视图、俯视图和左视图。每个视图都有自己的视图工具栏，你在某个视图中右上角点击一下，然后该视图就会被最大化。

![](【UE4】UE4基础/Snipaste_2019-10-15_11-12-21.png) 

**网格**

![](【UE4】UE4基础/Snipaste_2019-10-15_11-15-27.png)

## 5.世界大纲

世界大纲视图有层次地展示了在场景中的所有actor。

![](【UE4】UE4基础/Snipaste_2019-10-15_17-56-02.png)

在世界大纲视图你可以进行这些操作：
**新建文件夹**：你可以通过文件夹管理使得actor整洁有序，也可以通过文件夹来选中一组actor（右键文件夹，选择-所有子项）。

**隐藏actor**：在actor和文件夹前面有一只眼睛，通过点击它来隐藏/显示该actor或文件夹下的所有actor。
**附加actor**：通过拖动一个actor到另一个actor，可以形成附加关系。如果你移动父关系的actor，所有的子actor都会跟着移动。如果移动子actor，父actor就不会跟着移动。需要注意的是，这只能通过世界大纲视图完成，在视口中移动父actor是不会影响子actor的。 

左下角显示的是有多少个actor，右下角显示的是设置视图过滤方式的选项。

## 6.内容浏览器

所有游戏资源，包括材质、贴图、网格、蓝图、音频文件都会在这里显示出来。这里是导入、组织、观察甚至创建游戏资源的地方。 

![](【UE4】UE4基础/Snipaste_2019-10-15_17-55-17.png)

在顶部有三个图标，下面逐一介绍它们：

- 添加新项：创建新的资源，例如材质、粒子系统、蓝图等等。
- 导入：导入内容到项目文件中。
- 保存所有：如果在内容浏览器创建或修改资源，点击保存所有来保存这些工作。


然后接着下面有个搜索条，可以输入要搜索的资源名字来快速查找它们。右上角的锁图标可以锁住所有“在内容浏览器查找”的请求。所谓“在内容浏览器查找”就是在视口中右键actor的时候，弹出菜单中选择“在内容浏览器查找”就会将查找到的对应资源显示在内容浏览器中。如果锁住了，则不会在内容浏览器中显示出来，而是打开一个新的窗口显示。

在下方左侧有个源面板，源面板包含了你的项目中收集的所有文件夹。在下方右侧，是资源视图，显示了从源面板中选择的资源和子文件夹。在上方有个过滤器，可以指定你想要查看的资源类型。右方就是资源搜索栏。在底部左方你可以看见当前选择的文件夹有多少个资源，底部右方可以选择视图选项，选择你观察项目的方式，例如是平铺块、列表还是列显示方式 

## 7.细节

 在细节面板，你可以看见和修改当前选择的actor属性。 

![](【UE4】UE4基础/Snipaste_2019-10-15_18-02-03.png)

在顶部，你可以看到选择的actor的名称（图中是Chair）。你可以设置自己喜欢的命名。在右方，就是一个锁按钮。默认是解锁状态，当锁住的时候，细节面板会锁定当前的属性和细节，如果你选择另一个actor也不会改变。 

下方的搜索栏可以搜索你想查看的属性，接着是属性矩阵按钮，这会打开一个属性矩阵窗口。再右方是显示过滤器，你可以选择折叠/展开所有的种类、只显示修改的属性或显示高级属性。 

在名字的下方，有两个按钮，添加组件和蓝图/添加脚本。添加组件，可以添加例如静态网格、形状基本几何体（正方体、球体、圆柱和圆锥体），灯光actor等。这跟世界大纲视图中的附加Actor类似。接着，你可以转换选择的actor到蓝图类。蓝图类是作为一个组件，伴随着代码（Unity等一些其它引擎中，称为Prefab预制件）。

 最后，下方是属性区域，这里显示选择的actor属性,例如位置、旋转、缩放、当前的材质、添加和移走材质等等你可以修改的内容。 

# 三、UE4的快捷键

| 按键                   | 动作                             |
| :--------------------- | :------------------------------- |
| 鼠标左键               | 选择actor                        |
| 鼠标左键+拖动          | 前后移动和左右旋转摄像头         |
| 鼠标右键               | 选择actor并打开右键菜单          |
| 鼠标右键+拖动          | 旋转摄像头方向                   |
| 鼠标左键+鼠标右键+拖动 | 摄像头上下左右移动               |
| 鼠标中键+拖动          | 摄像头上下左右移动               |
| 滑轮向上               | 摄像机向前移动                   |
| 滑轮向下               | 摄像机向后移动                   |
| F                      | 聚焦选中的actor                  |
| 箭头方向键             | 摄像机前后左右移动               |
| W                      | 选中平移工具                     |
| E                      | 选中旋转工具                     |
| R                      | 选中缩放工具                     |
| W+任何鼠标按键         | 摄像机向前移动                   |
| S+任何鼠标按键         | 摄像机向后移动                   |
| A+任何鼠标按键         | 摄像机向左移动                   |
| D+任何鼠标按键         | 摄像机向右移动                   |
| E+任何鼠标按键         | 摄相机向上移动                   |
| Q+任何鼠标按键         | 摄像机向下移动                   |
| Z+任何鼠标按键         | 增加视野（鼠标释放后会恢复原状） |
| C+任何鼠标按键         | 缩小视野（鼠标释放后会恢复原状） |
| Ctrl+S                 | 保存场景                         |
| Ctrl+N                 | 创建新场景                       |
| Ctrl+O                 | 打开一个已有的场景               |
| Ctrl+Alt+S             | 另存为新场景                     |
| Alt+鼠标左键+拖动      | 复制当前选中的actor              |
| Alt+鼠标右键+拖动      | 摄像机前后移动                   |
| Alt+P                  | 进入Play预览模式                 |
| Esc                    | 退出预览模式                     |
| F11                    | 进入仿真模式                     |

# 四、UE4中的类

## 1.UObject类

Uobject类提供以下功能：

- Garbage collection垃圾收集
- Reference updating引用自动更新
- Reflection反射
- Serialization序列化
- Automatic updating of default property changes自动检测默认变量的更改
- Automatic property initialization自动变量初始化
- Automatic editor integration和虚幻引擎编辑器的自动交互
- Type information available at runtime:运行时类型识别
- Network replication网络复制

我将会详细讲述这些功能中重点功能的含义。

**垃圾收集**

C++的内存管理是由程序员完成的。因此对象管理一直是一个很棘手的问题。往往一个对象可能会引用多个其他对象，同一个对象也可能会被多个对象引用。那么，当你不需要用到当前对象A的时候，该不该释放该对象所在的内存区域？任何人都会犹豫释放一旦有别的对象引用当前对象，释放后就会产生野指针。当另一个对象来访问时，会看到空空如也甚至是其他对象的内存区域。不释放有可能我已经是最后一个引用这个对象的人了，一旦我丢弃这个指针，这个对象就不会再有人知道，这片内存区域永远无法被回收。对此虚幻引擎提供了如下两个解决方案

- 继承自 UObject类，同时指向 UObject类实例对象的指针成员变量，使用UPROPERTY宏进行标记。虚幻引擎的 UObject架构会自动地被 PRoperty标记的变量考虑到垃圾回收系统中，自动地进行对象的生命周期管理。

- 采用智能指针。请注意，只有非 UObject类型，才能够使用智能指针进行自动内存释放。

**反射**

反射并不是图形学意义上的“反射”。而是指一种语言的机制。这样的机制在C#、Java中已经存在，但是C++并没有。我以一种通俗易懂的解释来描述反射，如果你需要反射的详细解释，请阅读搜索引擎中对反射的解释如果你是一名C++程序员，那么请你思考一个问题我该如何在运行时获取一个类？有哪些成员变量、成员函数？我该如何获取这些成员变量的名字？很难对吗？C++本身没有提供这样一套机制。尽管你可以用各种方式来手动实现虚幻引擎实现了这样一套机制。

**序列化**

当你希望把一个类的对象保存到磁盘，同时在下次运行时完好无损地加载，那么你同样需要继承自 UObject类但是需要澄清的是，你可以通过给自己的纯C++类手动实现序列化所需要的函数来让这个类支持序列化功能。这并不是 UObject类独有的。

**与虚幻引擎编辑器的交互**

还记得虚幻引擎编辑器的 Editor面板吗？你希望你的类的变量能够被 Editor简单地编辑吗？那么你需要继承自这个类。

**运行时类型识别**

请注意，虚幻引擎打开了GR-编译器参数。意味着你无法使用C++标准的RTT1机制: dynamic-cast。如果你希望使用，请继承自 UObject类，然后使用cast<>函数来完成。这是因为虚幻引擎实现了一套自己的、更高效的运行时类型识别的方案。

**网络复制**

当你在进行网络游戏开发（c/s架构）时，你一定希望能够自动地处理变量的同步。而继承自 UObject类，其被宏标记的变量能够自动地完成网络复制的功能。从服务器端复制对应的变量到客户端。

综上所述，当你需要这些功能的时候，你的这个类应该继承自 UObject类，请注意: UObject类会在引擎加载阶段，创建一个 Default Object默认对象。这意味

- 构造函数并不是在游戏运行的时候调用，同时即便你只有一个 UObject对象存在于场景中，构造函数依然会被调用两次。

- 构造函数被调用的时候， WOrld不一定存在。 Get World0返回值有可能为空！

## 2.Actor类

Actor类具有组件挂载能力，即所有需要挂载组件的对象都需要继承Actor类，但是有一点是需要纠正的，Actor类不是必须的，说“Actor类是一切实体的基类”这种说法严格意义上来说是不正确的，比如：做一个管理类对象就不需要挂在其他的组件。

还需要注意的一点是，UE4中的component和Unity中的component是极大的区别的，在UE4中一个场景实体对应一个类，而Unity中一个场景实体可以挂载多个脚本组件，一个脚本组件就是一个类。

## 3.Pawn类

 Pawn类是一个代表你或者代表电脑的人工智能的游戏对象，它是可以在屏幕上控制的游戏对象。Pawn类是从Actor类中基础的，它可以通过玩家的设备（键盘、鼠标等）控制或者被人工智能脚本控制。如果它是被玩家控制的，我们通常称之为controller（控制器）；如果它是被人工智能脚本控制的，我们通常称之为AI（Artificial Intelligence，人工智能），如果你经常玩游戏，那些NPC（Non-player Characters，非玩家角色）就通常具有AI行为。 

## 4.Character类

Character类代表一个角色，它继承自Pawn类。那么，什么时候该继承自 Character类，什么时候该继承自Pawn类呢？这个问题的答案，我们必须从 Character类的定义中寻找—它提供了什么样的功能？Character类提供了一个特殊的组件， Character Movement。这个组件提供了一个基础的、基于胶囊体的角色移动功能。包括移动和跳跃，以及如果你需要，还能扩展出更多，例如蹲伏和爬行。如果你的Pawn类十分简单，或者不需要这样的移动逻辑（比如外星人飞船），那么你可以不继承自这个类。当然，现在很多游戏中的角色（无论是人类，还是某些两足行走的怪物），都能够适用Character类的逻辑。

## 5.Controller类

Controller是漂浮在 Pawn/Character之上的灵魂。它操纵着Pawn和 Character的行为。 Controller可以是AI， AI Controller类，你可以在这个类中使用虚幻引擎优秀的行为树/EQS环境查询系统。同样也可以是玩家， Player Controller类。你可以在这个类中绑定输入，然后转化为对Pawn的指令。为何虚幻引擎采用这样的设计。Epic给出的理由非常简单:“不同的怪物也许会共享同样的 Controller，从而获得类似的行为”。其实， Controller抽象掉了“怪物行为”，也就是扮演了有神论者眼中“灵魂”的角色。既然是灵魂，那么肉体就不唯一，因此灵魂可以通过 Possess/Un Possess来控制一个肉体，或者从一个肉体上离开。

## 6.各个类之间的层级关系

![](【UE4】UE4基础/Snipaste_2019-10-16_21-27-20.png)

# 五、UE4的反射和垃圾回收

UE4使用C++语言进行开发，但是C++并不支持反射和垃圾回收机制，所以UE4便自己实现了反射和垃圾回收。

### 反射

UE4使用一系列的宏来实现反射，在反射中用的宏主要有

| 宏        | 对应的反射对象 |
| --------- | -------------- |
| UCLASS    | C++类          |
| UFUNCTION | 函数           |
| UPROPERTY | 成员变量       |
| USTRUCT   | 结构体         |

<font color = red>要使用这些宏，必须包含头文件`#include "MyActor.generated.h"`，并且这个头文件还必须放在左后一位</font>。

### UE4是如何实现反射的呢？

我们要想要让某一块代码块可以被反射，我们就必须在这个代码块中使用上面的宏，如：我们想要某个类可以被反射，那么就必须在类前添加宏`UCLASS()`，并且面的函数，成员变量，结构体前也必须添加相应的宏。当我们添加了宏后，UE4在编译时会调用中头文件`.generate.h`中相应宏定义有关反射的方法，并通过Unreal Build Tool(UBT)和Unreal Header Tool(UHT)两个工具生成一个`.generate.cpp`文件，`.generate.h`文件则是一个包含了反射数据的C++代码。如此UE4便可以通过`.generate.cpp`来获取元数据。

### 垃圾回收

UE4的垃圾回收的使用有如下几种方式：

**继承自UObject类的类对象**

我们可以直接在成员变量前引入宏<font color=red>UPROPERTY()</font>，这个宏不仅可以标记反射还可以为垃圾回收做标记。

我们也可以是使用<font color=red>TWeakObjectPtr</font>指针，TWeakObjectPtr是一个弱指针，通常定义在类的内部用来操纵堆区中的对象。TWeakObjectPtr是一个泛型指针，使用时需要指定类型参数，如：

```
TWeakObjectPtr<ClassName> tw;
```

**局部的UObject类对象**

有时我们可能在函数中定义一个局部的UObject对象，为了防止对象被UObject的回收机制回收，我们应当使用<font color=red>AddToRoot()</font>来锁定对象，用完后使用<font color=red>RemoveFromRoot()</font>来移除锁定。

**不继承自UObject和UStruct的结构体和类**

这种结构体我们使用<font color=red>TSharedPtr</font>指针来引用堆区的对象，TSharedPtr也是一个泛型指针，使用时也需要指定类型参数。

如果我们想要使用引用而不是指针则使用TSharedRef，如：

```
TSharedRef<FMyCustom> MyCustom = MakeShared<FMyCustom>(); 
```

此时M有Custom就是`MakeShared<FMyCustom>()`返回对象的引用。

我们也可以使用<font color=red>TWeakPtr</font>指针，TWeakPtr指针的效果和TWeakObjectPtr指针的效果是一致的，只是TweakPtr用于非UObject类对象。

**当一个不继承自UObject的结构体中出现了UObject对象时**

这种情况下，结构体可以正常访问，但是结构体里的UObject对象会由于UObject的回收机制，在过一段时间后被销毁，从而导致这个对象无法访问和出现野指针的情况，UE4则使用<font color=red>FGCObject</font>类来解决这种情况，我们只需让这种情况下的结构体继承自FGCObject类积即可。

# 六、C++编程

## 1.使用Unreal Editor创建C++类

当我们创建一个C++编程模板时，在内容浏览器中会生成一个C++类文件夹，同时目录下还会生成一个项目名称文件夹，我们可以在对应的文件夹下右键创建一个C++类，选择新类需要继承的父类和存储位置后确定，UE4会自动打开VS，并生成一个`.cpp`文件和一个`.h文件`。

![](【UE4】UE4基础/Snipaste_2019-10-16_10-05-42.png)

![](【UE4】UE4基础/Snipaste_2019-10-16_10-06-10.png)

![](【UE4】UE4基础/Snipaste_2019-10-16_10-06-16.png)

![](【UE4】UE4基础/Snipaste_2019-10-16_10-07-00.png)

创建的C++类的`.h`文件的结构

![](【UE4】UE4基础/Snipaste_2019-10-16_10-40-52.png)

这里GENERATED_BODY()宏处有两种情况，我们可以使用GENERATED_UCLASS_BODY()宏和GENERATED_BODY()宏，二者的区别是:

使用了GENERATED_BODY()宏，我们的类中就不能直接使用父类中的声明，如果我们要去实现，我就必须在本类中声明。

使用GENERATED_UCLASS_BODY()宏，我们就可以使用父类声明的构造函数，在本类中不需要再声明，而可以直接实现即可。

## 2.手动创建C++类

## 3.UE4类的命名规则

UE4为一些常用类的命名添加了一些命名前缀，<font color=red> 如果我们不写这些前缀，UE4会编译错误</font>。

| 前缀 | 说明                               |
| ---- | ---------------------------------- |
| F    | 纯c++类                            |
| U    | 继承自UObject，但不继承自Actor的类 |
| A    | 继承自Actor的类                    |
| S    | Slate控件相关类                    |
| H    | HitResult相关类                    |

